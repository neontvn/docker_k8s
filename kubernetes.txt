Docker Terminology

Kubernetes Terminology

1. Kubernetes Cluster - collection of nodes
2. Node - Virtual machine that will run code
3. Pods - Running container. Technically a pod can run multiple containers
4. Deployment - Monitors a set of pods, makes sure they are running and restarts if crashed
5. Service - Provides an easy to remember URL to access a running container

Kubernetes Config Files
 - Tells Kubernetes about the Deployments, Pods, Services ( Referred to as Objects )
 - Written in YAML syntax
 - Documentation

Minikube : 

    --> Minikube runs a single-node Kubernetes cluster on your personal computer
    --> A one node cluster, where the master and worker processes are on the same machine.

Commands
    |_ minikube start
    |_ minikube dashboard
___________________________________________________________________________________________

Creating a Pod ( With example and explaination )

File - posts.yaml

apiVersion : v1
kind : Pod              // Type of Object we want to create
metadata :
    name : posts        // pod is given name of posts
spec :                  // Exact attributes  we want to apply to the object
    containers:         // We can create multiple containers inside a pod
        - name : posts                      // Container with name posts
          image : hungryshark/posts:0.0.1   // Image from which it is going to be created
          imagePullPolicy: IfNotPresent

kubectl apply -f posts.yaml     // To tell kubernetes to use this config file

kubectl get pods                        // Get information of the existing pods
kubectl exec -it [pod-name][command]    // Execute the given command in a running pod
kubectl logs [pod-name]                 // Prints out logs from the given pod
kubectl delete pod [pod-name]           // Delete the pod
kubectl apply -f [config file name]     // Tell k8s to process the config
kubectl describe pod [pod-name]         // Print out some information about the running pod
___________________________________________________________________________________________


DEPLOYMENTS

- Rather than creating individual pods we create a Deployment object which manages a set of k8s pods.
- Pod crashes, then deployment automatically creates the pods for us.
- Version of pods may change in due course of time. Deployment helps in managing the same.

CREATING A DEPLOYMENT

File - posts-depl.yaml

apiVersion : apps/v1
kind : Deployment               // Type of Object we want to create
metadata : 
    name : posts-depl           // Name of the deployment   
spec :                          // How deployment should behave
    replicas : 1                // Number of pods running a particular image
    selector :                  // Deployment gets to know which pods to manage
        matchLabels :
            app : posts         // Key : Value can be xyz : posts as well
    template :                  // Specify exact config of pod to be created
        metadata :
            labels:
                app : posts     // Key : value pair assigned same as above
        spec :                  // Config of pods
            containers :            // Container created in pod
                -   name : posts    // Container with name posts
                    image : hungryshark/posts:latest    // Image to be run in the container
                    
___________________________________________________________________________________________


kubectl apply -f [config file name]             // Create deployment out of config file
kubectl get deployments                         // Lists all the deployments
kubectl describe deployment [depl name]         // Print out details of specific deployment
kubectl delete deployment [depl-name]           // Delete a deployment

___________________________________________________________________________________________


Updating a deployment : Two ways to do it

First Method

1. Make a change to your project code
2. Rebuild the image, specifying a new image Version
3. In the deployment config file, update the version of the image
4. Run kubectl apply -f [depl file name]

Second Method ( Generally preferred )

1. The deployment must be using the 'latest' tag in the pod spec section
2. Make an update to the code
3. Build the image
4. Push the image to docker hub
5. Run the command :  kubectl rollout restart deployment [depl-name]

___________________________________________________________________________________________

SERVICES

Types of Services
    - Cluster IP - Set up an easy-to-remember URL to access a pod. Only exposes pods in the cluster
    - Node Port - Makes a pod accessible from outside the cluster. Usualy for dev purposes
    - Load Balancer - Makes a pod accessible from outside the cluster.
    - External Name - Redirects as in-cluster request to a CNAME URL


NodePort - File posts-srv.yaml

apiVersion : v1
kind : Service
metadata :
    name : posts-serv
spec:
    type : NodePort             // Object type
    selector:
        app : posts             // This service is applicable to this app
    ports :
        - name : posts          // Details of the port
          protocol : TCP
          port : 4000           // Port number of Node Port Service
          targetPort : 4000     // Port number of where the posts app is served ( mentioned in posts/index.js )


kubectl apply -f posts-srv.yaml

Command - kubectl get services
Output - posts-serv   NodePort    10.105.8.62   <none>   4000:32536/TCP   8m27s

4000:32536/TCP - Here 32536 is the port at which the app is made accessible from outside the cluster

minikube ip - Gives the ip address of the minikube cluster
Generally, 192.x.x.x

Example, 192.168.44.2:32536/posts 

___________________________________________________________________________________________

CLUSTER IP Services

contd to the above file
---
apiVersion : v1
kind : Service
metadata : 
    name : posts-clusterip-srv
spec : 
    selector : 
        app : posts
    ports :
        - name : posts
          protocol : TCP
          port : 4000   
          targetPort : 4000



